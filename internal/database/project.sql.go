// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const checkProjectExistsByName = `-- name: CheckProjectExistsByName :one
SELECT EXISTS (
    SELECT 1 FROM projects WHERE name = $1
) AS exists
`

func (q *Queries) CheckProjectExistsByName(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProjectExistsByName, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (name, status, link, description, metadata, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, status, link, description, metadata, created_at, updated_at
`

type CreateProjectParams struct {
	Name        string
	Status      string
	Link        sql.NullString
	Description sql.NullString
	Metadata    pqtype.NullRawMessage
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Name,
		arg.Status,
		arg.Link,
		arg.Description,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Link,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProjectByName = `-- name: DeleteProjectByName :exec
DELETE FROM projects
WHERE name = $1
`

func (q *Queries) DeleteProjectByName(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteProjectByName, name)
	return err
}

const getProjectByName = `-- name: GetProjectByName :one
SELECT id, name, status, link, description, metadata, created_at, updated_at FROM projects
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetProjectByName(ctx context.Context, name string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByName, name)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Link,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectIdByName = `-- name: GetProjectIdByName :one
SELECT id FROM projects
WHERE name = $1
`

func (q *Queries) GetProjectIdByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getProjectIdByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getProjectStatusById = `-- name: GetProjectStatusById :one
SELECT status FROM projects
WHERE id = $1
`

func (q *Queries) GetProjectStatusById(ctx context.Context, id int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getProjectStatusById, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const listAllProjects = `-- name: ListAllProjects :many
SELECT id, name, status, link, description, metadata, created_at, updated_at FROM projects
ORDER BY created_at DESC
`

func (q *Queries) ListAllProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listAllProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNProjects = `-- name: ListNProjects :many
SELECT id, name, status, link, description, metadata, created_at, updated_at FROM projects
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListNProjects(ctx context.Context, limit int32) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listNProjects, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByStatus = `-- name: ListProjectsByStatus :many
SELECT id, name, status, link, description, metadata, created_at, updated_at FROM projects
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListProjectsByStatus(ctx context.Context, status string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjectsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Link,
			&i.Description,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProjectMetadata = `-- name: UpdateProjectMetadata :exec
UPDATE projects
SET metadata = $2, updated_at = $3
WHERE name = $1
`

type UpdateProjectMetadataParams struct {
	Name      string
	Metadata  pqtype.NullRawMessage
	UpdatedAt time.Time
}

func (q *Queries) UpdateProjectMetadata(ctx context.Context, arg UpdateProjectMetadataParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectMetadata, arg.Name, arg.Metadata, arg.UpdatedAt)
	return err
}

const updateProjectStatus = `-- name: UpdateProjectStatus :exec
UPDATE projects
SET status = $2, updated_at = $3
WHERE name = $1
`

type UpdateProjectStatusParams struct {
	Name      string
	Status    string
	UpdatedAt time.Time
}

func (q *Queries) UpdateProjectStatus(ctx context.Context, arg UpdateProjectStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateProjectStatus, arg.Name, arg.Status, arg.UpdatedAt)
	return err
}

const updateProjectStatusById = `-- name: UpdateProjectStatusById :one
UPDATE projects
SET status = $2, updated_at = $3
WHERE id = $1
RETURNING id, name, status, link, description, metadata, created_at, updated_at
`

type UpdateProjectStatusByIdParams struct {
	ID        int32
	Status    string
	UpdatedAt time.Time
}

func (q *Queries) UpdateProjectStatusById(ctx context.Context, arg UpdateProjectStatusByIdParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProjectStatusById, arg.ID, arg.Status, arg.UpdatedAt)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Link,
		&i.Description,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
